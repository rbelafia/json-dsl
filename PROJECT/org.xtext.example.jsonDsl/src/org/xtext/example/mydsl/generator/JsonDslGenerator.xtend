/*
 * generated by Xtext 2.23.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.jsonDsl.*
import org.xtext.example.mydsl.jsonDsl.impl.*
import org.eclipse.xtext.Conjunction
import java.util.ArrayList
import java.util.List
import java.util.regex.Pattern
import java.util.regex.Matcher
import java.util.LinkedHashMap
import java.io.*
import org.eclipse.xtext.validation.Check

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
class FieldPossessor {
		
	public static int index = 0
	
	def static void increment() {index++}
	
	def static void decrement() {index--}
	
}
	


class JsonDslGenerator extends AbstractGenerator {
	
	public var mustPrint = false
	
	public var filesToLoad = new LinkedHashMap<String, String>()
	
	public var fileToExport = null
	
	
	
	// COMPILE PYTHON
	def dispatch String compilePython(PointerCall pointer) '''obj«index»'''
	
	def dispatch String compilePython(Assignment assignment) '''«compilePython(assignment.leftHandSide)» = «compilePython(assignment.rightHandSide)»'''
	
	def dispatch String compilePython(Print procCall) '''json_print(«compilePython(procCall.expression)»)'''
	
	def dispatch String compilePython(DisjunctionExpression disjunctionExpression) '''disjunction(«compilePython(disjunctionExpression.left)», «compilePython(disjunctionExpression.right)»)'''
	
	def dispatch String compilePython(ArrayCall call) '''«compilePython(call.callee)»[«compilePython(call.specifier)»]'''
	
	def dispatch String compilePython(UnarySpecifier specifier) '''«specifier.index»'''
	
	def dispatch String compilePython(RangeSpecifier specifier) '''«specifier.from»:«specifier.to»'''
	
	def dispatch String compilePython(FieldCall call) '''«compilePython(call.callee)»['«call.field»']'''
	
	def dispatch String compilePython(ConjunctionExpression conjunctionExpression) '''conjunction(«compilePython(conjunctionExpression.left)», «compilePython(conjunctionExpression.right)»)'''
	
	def dispatch String compilePython(EqualityExpression equalityExpression) '''equal(«compilePython(equalityExpression.left)», «compilePython(equalityExpression.right)»)'''
	
	def dispatch String compilePython(InequalityExpression inequalityExpression) '''not_equal(«compilePython(inequalityExpression.left)», «compilePython(inequalityExpression.right)»)'''
	
	def dispatch String compilePython(SuperiorExpression superiorExpression) '''superior(«compilePython(superiorExpression.left)», «compilePython(superiorExpression.right)»)'''
	
	def dispatch String compilePython(SuperiorOrEqualExpression superiorOrEqualExpression) '''superior_or_equal(«compilePython(superiorOrEqualExpression.left)», «compilePython(superiorOrEqualExpression.right)»)'''
	
	def dispatch String compilePython(InferiorExpression inferiorExpression) '''inferior(«compilePython(inferiorExpression.left)», «compilePython(inferiorExpression.right)»)'''
	
	def dispatch String compilePython(InferiorOrEqualExpression inferiorOrEqualExpression) '''inferior_or_equal(«compilePython(inferiorOrEqualExpression.left)», «compilePython(inferiorOrEqualExpression.right)»)'''
	
	def dispatch String compilePython(AdditionExpression additionExpression) '''addition(«compilePython(additionExpression.left)», «compilePython(additionExpression.right)»)'''
	
	def dispatch String compilePython(SubstractionExpression substractionExpression) '''substraction(«compilePython(substractionExpression.left)», «compilePython(substractionExpression.right)»)'''
	
	def dispatch String compilePython(MultiplicationExpression multiplicationExpression) '''multiplication(«compilePython(multiplicationExpression.left)», «compilePython(multiplicationExpression.right)»)'''
	
	def dispatch String compilePython(DivisionExpression divisionExpression) '''division(«compilePython(divisionExpression.left)», «compilePython(divisionExpression.right)»)'''
	
	def dispatch String compilePython(ModuloExpression moduloExpression) '''modulo(«compilePython(moduloExpression.left)», «compilePython(moduloExpression.right)»)'''
	
	def dispatch String compilePython(LogicalNegationExpression logicalNegationExpression) '''logical_negation(«compilePython(logicalNegationExpression.sub)»)'''
	
	def dispatch String compilePython(UnaryMinusExpression unaryMinusExpression) '''unary_minus(«compilePython(unaryMinusExpression.sub)»)'''
	
	def dispatch String compilePython(UnaryPlusExpression unaryPlusExpression) '''unary_plus(«compilePython(unaryPlusExpression.sub)»)'''
	
	def dispatch String compilePython(BracketExpression bracketExpression) '''(«compilePython(bracketExpression.sub)»)'''
	
	def dispatch String compilePython(Load load) {return "load_json('" + load.fileName + "')"}
	
	def dispatch String compilePython(Store store){return "store_json(" + compilePython(store.expression) + ", '" + store.fileName + "')"}
	
	def dispatch String compilePython(Export export){
		if (export.fileName === null) throw new RuntimeException("Path to csv output must be indicated for a Python compilation") 
		return "export_csv(" + compilePython(export.expression) + ", '" + export.fileName + "')"
	}
	
	def dispatch String compilePython(Depth depth)'''depth_json(«compilePython(depth.expression)»)'''
	
	def dispatch String compilePython(FieldInfo field)'''infos_json(«compilePython(field.expression)»)'''
	
	def dispatch String compilePython(Contains contains)'''contains(«compilePython(contains.right)», «FOR key : contains.keys SEPARATOR ", "»«compilePython(key)»«ENDFOR»)'''
	
	def static String index() '''«FieldPossessor.index»'''
	
	def dispatch String compilePython(Select select) {
		FieldPossessor.increment
		val res = '''[{key«index»: obj«index»[key«index»] for key«index» in («FOR field: select.fields SEPARATOR ", "»«compilePython(field)»«ENDFOR»)} for obj«index» in «compilePython(select.fromExpression)» if («compilePython(select.whereExpression)»)]'''
		FieldPossessor.decrement
		return res
	}
		
	def dispatch String compilePython(Length length)'''len(«compilePython(length.expression)»)'''
	
	def dispatch String compilePython(Sum sum) {
		FieldPossessor.increment
		val res ='''reduce(addition, [obj«index»«IF sum.field !== null»[«compilePython(sum.field)»]«ENDIF» for obj«index» in «compilePython(sum.expression)»«IF sum.whereExpression !== null» if («compilePython(sum.whereExpression)»)«ENDIF»])'''
		FieldPossessor.decrement
		return res
	}
	
	def dispatch String compilePython(Product prod) {
		FieldPossessor.increment
		val res ='''reduce(multiplication, [obj«index»«IF prod.field !== null»[«compilePython(prod.field)»]«ENDIF» for obj«index» in «compilePython(prod.expression)»«IF prod.whereExpression !== null» if («compilePython(prod.whereExpression)»)«ENDIF»])'''
		FieldPossessor.decrement
		return res
	}
		
	def dispatch String compilePython(Array array) '''[«FOR value : array.values SEPARATOR ", "»«compilePython(value)»«ENDFOR»]'''

	def dispatch String compilePython(JSonObject jSonObject) '''{«FOR field : jSonObject.fields SEPARATOR ", "»«compilePython(field.key)»: «compilePython(field.value)»«ENDFOR»}'''
	
	def dispatch String compilePython(Primitive primitive) {
		if(primitive.str !== null) return "'" + primitive.str + "'"
		else if (primitive.floatNum !== null) return '''«primitive.floatNum»'''
		else if (primitive.bool !== null) return Boolean.parseBoolean(primitive.bool) ? '''True''' : '''False'''
		else if (primitive.nil !== null) return '''None'''
		else return '''«primitive.intNum»''' 
	}
	
	def dispatch String compilePython(VariableCall call) '''«call.name»'''
	
	
	// COMPILE JQ
	
	def dispatch String compileJQ(Print print) {
		throw new RuntimeException("Print not supported for JQ compilation")
	}
	
	def dispatch String compileJQ(Primitive primitive) {
		if(primitive.str !== null) return '"' + primitive.str + '"'
		else if (primitive.floatNum !== null) return '''«primitive.floatNum»'''
		else if (primitive.bool !== null) return Boolean.parseBoolean(primitive.bool) ? '''true''' : '''false'''
		else if (primitive.nil !== null) return '''null'''
		else return '''«primitive.intNum»''' 
	}
	
	def dispatch String compileJQ(PointerCall pointer)'''.'''
	
	def dispatch String compileJQ(Array array) '''[«FOR value : array.values SEPARATOR ", "»«compileJQ(value)»«ENDFOR»]'''
	
	def dispatch String compileJQ(JSonObject jSonObject) '''{«FOR field : jSonObject.fields SEPARATOR ", "»«compileJQ(field.key)»: «compileJQ(field.value)»«ENDFOR»}'''
	
	def dispatch String compileJQ(VariableCall call) '''$«call.name»'''
	
	def dispatch String compileJQ(Assignment assignment) '''(«compileJQ(assignment.rightHandSide)») as «compileJQ(assignment.leftHandSide)»'''
	
	def dispatch String compileJQ(DisjunctionExpression disjunctionExpression) '''«compileJQ(disjunctionExpression.left)» or «compileJQ(disjunctionExpression.right)»'''
	
	def dispatch String compileJQ(ConjunctionExpression conjunctionExpression) '''«compileJQ(conjunctionExpression.left)» and «compileJQ(conjunctionExpression.right)»'''
	
	def dispatch String compileJQ(EqualityExpression equalityExpression) '''«compileJQ(equalityExpression.left)» == «compileJQ(equalityExpression.right)»'''
	
	def dispatch String compileJQ(InequalityExpression inequalityExpression) '''«compileJQ(inequalityExpression.left)» != «compileJQ(inequalityExpression.right)»'''	
	
	def dispatch String compileJQ(SuperiorExpression superiorExpression) '''«compileJQ(superiorExpression.left)» > «compileJQ(superiorExpression.right)»'''
	
	def dispatch String compileJQ(SuperiorOrEqualExpression superiorOrEqualExpression) '''«compileJQ(superiorOrEqualExpression.left)» >= «compileJQ(superiorOrEqualExpression.right)»'''
	
	def dispatch String compileJQ(InferiorExpression inferiorExpression) '''«compileJQ(inferiorExpression.left)» < «compileJQ(inferiorExpression.right)»'''
	
	def dispatch String compileJQ(InferiorOrEqualExpression inferiorOrEqualExpression) '''«compileJQ(inferiorOrEqualExpression.left)» <= «compileJQ(inferiorOrEqualExpression.right)»'''
	
	def dispatch String compileJQ(AdditionExpression additionExpression) '''«compileJQ(additionExpression.left)» + «compileJQ(additionExpression.right)»'''
	
	def dispatch String compileJQ(SubstractionExpression substractionExpression) '''«compileJQ(substractionExpression.left)» - «compileJQ(substractionExpression.right)»'''
	
	def dispatch String compileJQ(MultiplicationExpression multiplicationExpression) '''«compileJQ(multiplicationExpression.left)» * «compileJQ(multiplicationExpression.right)»'''
	
	def dispatch String compileJQ(DivisionExpression divisionExpression) '''«compileJQ(divisionExpression.left)» / «compileJQ(divisionExpression.right)»'''
	
	def dispatch String compileJQ(ModuloExpression moduloExpression) '''«compileJQ(moduloExpression.left)» % «compileJQ(moduloExpression.right)»'''
	
	def dispatch String compileJQ(LogicalNegationExpression logicalNegationExpression) '''! «compileJQ(logicalNegationExpression.sub)»'''
	
	def dispatch String compileJQ(UnaryMinusExpression unaryMinusExpression) '''- «compileJQ(unaryMinusExpression.sub)»'''
	
	def dispatch String compileJQ(UnaryPlusExpression unaryPlusExpression) '''+ «compileJQ(unaryPlusExpression.sub)»'''
	
	def dispatch String compileJQ(BracketExpression bracketExpression) '''(«compileJQ(bracketExpression.sub)»)'''
	
	def dispatch String compileJQ(ArrayCall call) '''«compileJQ(call.callee)»[«compileJQ(call.specifier)»]'''
	
	def dispatch String compileJQ(UnarySpecifier specifier) '''«specifier.index»'''
	
	def dispatch String compileJQ(RangeSpecifier specifier) '''«specifier.from»:«specifier.to»'''
	
	def dispatch String compileJQ(FieldCall call) '''«compileJQ(call.callee)»["«call.field»"]'''
	
	def dispatch String compileJQ(Load load) {
		if (load.fileName === null) '''$in'''
		else throw new RuntimeException("Load filename not supported for JQ compilation")
	}
	
	def dispatch String compileJQ(Store store) {
		throw new RuntimeException("Store not supported for JQ compilation")
	}
	
	def dispatch String compileJQ(Export export) {
		if (export.fileName === null) return '''«compileJQ(export.expression)» | csv'''
		else throw new RuntimeException("Cannot specify export path for JQ compilation")
	}
	
	def dispatch String compileJQ(Depth depth)'''depth(«compileJQ(depth.expression)»)'''
	
	def dispatch String compileJQ(FieldInfo field)'''«compileJQ(field.expression)» | map_values(type)'''
	
	def dispatch String compileJQ(Contains contains)'''«compileJQ(contains.right)» | «FOR key : contains.keys SEPARATOR " and "»has(«compileJQ(key)»)«ENDFOR»'''
	
	def dispatch String compileJQ(Select select)'''«compileJQ(select.fromExpression)»«IF select.whereExpression !== null» | map(select(«compileJQ(select.whereExpression)»))«ENDIF»«IF !select.fields.empty» | map(with_entries(select(«FOR field : select.fields SEPARATOR " or "».key == «compileJQ(field)»«ENDFOR»)))«ENDIF»'''
	
	def dispatch String compileJQ(Sum sum)'''«compileJQ(sum.expression)» | «IF sum.whereExpression !== null»map(select(«compileJQ(sum.whereExpression)»)) | «ENDIF»«IF sum.field !== null»map(.[«compileJQ(sum.field)»]) | «ENDIF»add'''
	
	def dispatch String compileJQ(Product prod)'''«compileJQ(prod.expression)» | «IF prod.whereExpression !== null»map(select(«compileJQ(prod.whereExpression)»)) | «ENDIF»«IF prod.field !== null»map(.[«compileJQ(prod.field)»]) | «ENDIF»product'''
	
	def dispatch String compileJQ(Length length)'''«compileJQ(length.expression)» | length'''
	
	// JQ COMPILATION
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val root = resource.allContents.head as Model
		
		var compiled_stms = newArrayList()
		for (stmt: root.stmts) compiled_stms.add(compileJQ(stmt))
		
		var res = '''def depth (obj): obj | if type == "object" then (map(1 + depth(.)) as $rec | if ($rec | length) == 0 then 1 else ($rec | max) end) else 0 end;'''
		res += '''def csv : (map(keys) | add | unique) as $cols | map(. as $row | $cols | map($row[.])) as $rows | $cols, $rows[] | @csv;'''	
		res += '''def product: . as $array | reduce $array[] as $item ( ($array[0] | type | if . == "number" then 1 elif . == "string" then 1 elif . == "object" then {} else null end); . * $item);'''
		res += '''«FOR stmt : compiled_stms SEPARATOR "|"»«stmt»«ENDFOR» '''
		
		fsa.generateFile("result.jq", res)
    	
	}
	
	// PYTHON COMPILATION
	/* 
	def void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val root = resource.allContents.head as Model
		
		var compiled_stms = newArrayList()
		for (stmt: root.stmts) compiled_stms.add(compileJQ(stmt))
		
		val library = '''
		import json
		import csv
		from itertools import zip_longest
		from functools import reduce
		from copy import copy
		
		
		class JsonOperationException(Exception):
		    def __init__(self, left, right, operation):
		        self.left = left
		        self.right = right
		        self.operation = operation
		        self.message = str(type(left)) + " and " + str(type(right)) + " are not compatible for operation" + operation
		        super().__init__(self.message)
		
		
		
		def disjunction(left, right):
		
		    return (left is not None and left is not False) or (right is not None and right is not False)
		
		
		def conjunction(left, right):
		
		    return (left is not None and left is not False) and (right is not None and right is not False)
		
		def addition(left, right):
		
		    if left is None:
		        return right
		    elif right is None:
		        return left
		
		    if type(left) is list:
		        assert type(right) is list, 'can only concat list with list'
		        return left + right
		
		    elif type(left) is int or type(left) is float:
		        assert type(right) is int or type(right) is float, 'can only add numbers with numbers'
		        return left + right
		
		    elif type(left) is str:
		        assert type(right) is str, 'can only concat strings with strings (try using TO_STRING)'
		        return left + right
		
		    elif type(left) is dict:
		        assert type(right) is dict, 'can only concat object with object (try using INSERT)'
		        res = copy(left)
		        res.update(right)
		        if res is None:
		            return {}
		        else:
		            return res
		
		    else:
		        raise JsonOperationException(left, right, "addition")
		
		
		def substraction(left, right):
		    if type(left) is int or type(left) is float:
		        assert type(right) is int or type(right) is float, 'can only substract numbers with numbers'
		        return left - right
		
		    elif type(left) is list:
		        assert type(right) is list, 'can only substract list with list'
		        res = copy(left)
		        for i in left:
		            if i in right:
		                res.remove(i)
		        return res
		
		    else:
		        raise JsonOperationException(left, right, "substraction")
		
		def multiplication(left, right):
		
		    if type(left) is int or type(left) is float:
		        assert type(right) is int or type(right) is float or type(right) is str, ''
		        if type(right) is str:
		            if int(left) == 0:
		                return None
		            else:
		                return int(left) * right
		        else:
		            return left * right
		
		    elif type(left) is str:
		        assert type(right) is int or type(right) is float, ''
		        if int(right) == 0:
		            return None
		        else:
		            return left * int(right)
		
		    elif type(left) is dict:
		        assert type(right) is dict, ''
		        res = left
		        for key, value in right.items():
		            if key in res and type(res[key]) is dict and type(value) is dict:
		                res[key] = multiplication(res[key], value)
		            else:
		                res[key] = value
		        if res is None:
		            return {}
		        else:
		            return res
		
		    else:
		        raise JsonOperationException(left, right, "multiplication")
		
		
		def division(left, right):
		    if left is None:
		        return right
		    elif right is None:
		        return left
		
		    if type(left) is int or type(left) is float:
		        assert type(right) is int or type(right) is float, 'can only substract numbers with numbers'
		        return left / right
		
		    elif type(left) is str:
		        assert type(right) is str, ''
		        return left.split(right)
		
		    else:
		        raise JsonOperationException(left, right, "division")
		
		
		def modulo(left, right):
		
		    if type(left) is int or type(left) is float:
		        assert type(right) is int or type(right) is float, 'can only modulate numbers with numbers'
		        return int(left % right)
		
		    else:
		        raise JsonOperationException(left, right, "modulate")
		
		
		def strict_equal(left, right):
		    return left == right
		
		
		def equal(left, right):
		    return (type(left) is type(right)) and left == right
		
		
		def strict_not_equal(left, right):
		    return left != right
		
		
		def not_equal(left, right):
		    return not equal(left, right)
		
		
		def superior(left, right):
		    if left is None:
		        return False
		    else:
		        if right is None:
		            return True
		        elif type(left) is dict:
		            if type(right) is dict:
		                for (x, y) in zip_longest(left.keys(), right.keys(), fillvalue=False):
		                    if not_equal(x, y):
		                        return superior(x, y)
		                for (x, y) in zip_longest(left.values(), right.values(), fillvalue=False):
		                    if not_equal(x, y):
		                        return superior(x, y)
		                return False
		            else:
		                return True
		        elif type(left) is list:
		            if type(right) is dict:
		                return False
		            elif type(right) is list:
		                for (x, y) in zip_longest(left, right, fillvalue=False):
		                    if x != y:
		                        return superior(x, y)
		                return False
		            else:
		                return True
		        elif type(left) is str:
		            if type(right) is dict or type(right) is list:
		                return False
		            elif type(right) is str:
		                if len(left) != len(right):
		                    return len(left) > len(right)
		                else:
		                    return left > right
		            else:
		                return True
		        elif type(left) is int or type(left) is float:
		            if type(right) is dict or type(right) is list or type(right) is str:
		                return False
		            elif type(right) is int or type(right) is float:
		                return left > right
		            else:
		                return True
		        elif type(left) is bool:
		            if type(right) is bool:
		                return left and not right
		            else:
		                return False
		
		
		def superior_or_equal(left, right):
		    return superior(left, right) or equal(left, right)
		
		
		def inferior(left, right):
		    return superior(right, left)
		
		
		def inferior_or_equal(left, right):
		    return inferior(left, right) or equal(left, right)
		
		
		def logical_negation(elem):
		    if type(elem) is list:
		        return [logical_negation(x) for x in elem]
		
		    else:
		        assert type(elem) is bool, 'can only negate boolean'
		        return not elem
		
		
		def unary_minus(elem):
		    if type(elem) is list:
		        return [unary_minus(x) for x in elem]
		
		    else:
		        assert type(elem) is int or float, ''
		        return - elem
		
		
		def unary_plus(elem):
		    if type(elem) is list:
		        return [unary_plus(x) for x in elem]
		
		    else:
		        assert type(elem) is int or float, ''
		        return + elem
		
		
		def load_json(path):
		    with open(path) as file:
		        return json.load(file)
		
		
		def store_json(obj, path):
		    with open(path, 'w') as file:
		        json.dump(obj, file)
		
		
		def export_csv(obj: list, path):
		    with open(path, 'w') as output_file:
		        output = csv.writer(output_file)
		        output.writerow(obj[0].keys())
		        for row in obj:
		            output.writerow(row.values())
		
		
		def depth_json(obj: dict):
		    rec = []
		    for v in obj.values():
		        if isinstance(v, dict):
		            rec.append(1 + depth_json(v))
		
		    if len(rec) == 0:
		        return 1
		    else:
		        return max(rec)
		
		
		def infos_json(obj: dict):
		    res = {}
		    for key, value in obj.items():
		        if isinstance(value, int) or isinstance(value, float):
		            res[key] = "Number"
		        elif isinstance(value, str):
		            res[key] = "String"
		        elif isinstance(value, bool):
		            res[key] = "Boolean"
		        elif value is None:
		            res[key] = "Null"
		        elif isinstance(value, list):
		            res[key] = "Array"
		        else:
		            res[key] = infos_json(value)
		    return res
		
		
		def contains(obj, *keys):
		    for k in keys:
		        if k not in obj:
		            return False
		    return True
		
		
		def concat(*obj):
		    res = 0
		    if isinstance(obj[0], dict):
		        res = {}
		        for e in obj:
		            assert isinstance(e, dict), "Cannot concat object with " + str(type(e))
		            res.update(e)
		
		    elif isinstance(obj[0], list):
		        res = []
		        for e in obj:
		            if isinstance(e, list):
		                res += e
		            else:
		                res.append(e)
		
		    return res
		
		def json_print(x):
		    print(aux_print(x, 0))
		
		
		def aux_print(x, nb_tab):
		    if type(x) is dict:
		        res = '{'
		        sep = False
		        for key, value in x.items():
		            if sep:
		                res += ",\n" + "  " * (nb_tab + 1) + key + ': ' + str(aux_print(value, nb_tab + 1))
		            else:
		                sep = True
		                res += "\n" + "  " * (nb_tab + 1) + key + ': ' + str(aux_print(value, nb_tab + 1))
		        if sep:
		            res += "\n" + "  " * nb_tab + '}'
		        else:
		            res += '}'
		        return res
		    elif type(x) is list:
		        res = '['
		        sep = False
		        for value in x:
		            if sep:
		                res += ",\n" + "  " * (nb_tab + 1) + str(aux_print(value, nb_tab + 1))
		            else:
		                sep = True
		                res += "\n" + "  " * (nb_tab + 1) + str(aux_print(value, nb_tab + 1))
		        if sep:
		            res += "\n" + "  " * nb_tab + ']'
		        else:
		            res += ']'
		        return res
		    elif type(x) is float:
		        return int(x) if float.is_integer(x) else x
		    else:
		        return x'''
		
		fsa.generateFile("jz_library.py", library)
		
		var res = '''
		from jz_library import *
		«FOR compiled : compiled_stms»
		«compiled»
		«ENDFOR»
		'''
    	
    	fsa.generateFile("result.py", res)
	}
}
*/

}

